<div class="step-text">
<h5 id="theory">Theory</h5><p>In multi-agent systems, each agent handles its own specialized task. But when working with complex workflows, these agents need to work together, passing data from one step to the next. This orchestration<strong> </strong>process helps streamline how they interact and cuts down on complexity. Orchestration involves managing how data flows between agents, making sure each one gets exactly the input it needs and produces structured outputs that the next agent can use.</p><p>In this stage, we're adding this orchestration: the <strong>Manager Agent</strong>. It will simplify your pipeline by linking your existing <strong>Inventory Agent</strong> and <strong>Diet Agent</strong> into one single workflow. The Manager Agent will automatically send outputs from one agent to the next, giving you a clean and simple endpoint for the client.</p><p>By using orchestration, your system becomes much easier to use and expand. Users only need to make one request to get the combined result, instead of manually calling multiple agents one after another.</p><h5 id="description">Description</h5><p>Let's combine our previously created <strong>Inventory Agent</strong> and <strong>Diet Agent</strong> into a unified pipeline using a new agent: the <strong>Manager Agent</strong>. This agent runs the workflow by following these steps in order:</p><ol><li><p>Inventory step: The <code class="language-python">ManagerAgent</code> calls the <code class="language-python">InventoryAgent</code>, passes the user's list of items, and gets back a cleaned, validated list of usable items.</p></li><li><p>Diet filtering step: The <code class="language-python">ManagerAgent</code> then takes the output from the <code class="language-python">InventoryAgent</code> and passes it to the <code class="language-python">DietAgent</code> along with the user's dietary restrictions. This gives us a list of diet-friendly items and creative recipe suggestions.</p></li></ol><p>We need to implement <code class="language-python">ManagerAgent</code> in a separate module (<code class="language-python">app/agents/manager_agent.py</code>) and expose its functionality through a single FastAPI endpoint (<code class="language-python">POST /ask</code>), which makes things much simpler for the client.</p><p>The Pydantic model for the <code class="language-python">/ask</code> route input can be defined as</p><pre><code class="language-python">class AskInput(BaseModel):
    items: List[str]
    diet: str</code></pre><p>The ManagerAgent's response will contain:</p><pre><code class="language-json">{
  "usable_items": [...],
  "diet_filtered": [...],
  "suggestions": [...]
}</code></pre><p>This endpoint makes client-side logic much simpler, offering a streamlined experience and clearer data management.</p><h5 id="objectives">Objectives</h5><ul><li><p>Implement the ManagerAgent:</p><ul><li><p>Call <code class="language-python">InventoryAgent.run(items)</code> to get <code class="language-python">usable_items</code>.</p></li><li><p>Pass <code class="language-python">usable_items</code> to <code class="language-python">DietAgent.run(usable_items, diet)</code> to get <code class="language-python">compatible_items</code> and <code class="language-python">suggested_recipe_ideas</code>.</p></li><li><p>Return structured JSON data containing all three outputs.</p></li></ul></li><li><p>Define a new Pydantic model (<code class="language-python">AskInput</code>) in <code class="language-python">app/main.py</code> with items and diet fields.</p></li><li><p>Create a single FastAPI endpoint (<code class="language-python">POST /ask</code>) that handles requests using <code class="language-python">AskInput</code> and returns the combined result from <code class="language-python">ManagerAgent</code>.</p></li><li><p>Make sure all data passed between agents follows the JSON schemas we defined earlier, enabling robust and error-free parsing.</p></li></ul><h5 id="example">Example</h5><p><strong>Request</strong></p><pre><code class="language-bash"># Example request
curl -X POST http://localhost:8000/ask \
     -H 'Content-Type: application/json' \
     -d '{"items":["tomato","chicken","spinach"],"diet":"keto"}'</code></pre><p><strong>Expected Response</strong></p><pre><code class="language-json">{
  "usable_items": ["tomato","chicken","spinach"],
  "diet_filtered": ["tomato","chicken","spinach"],
  "suggestions": [
    "Keto Chicken Spinach Salad",
    "Keto Tomato Chicken Stir-Fry",
    "Spinach &amp; Chicken Keto Bowl",
    "Chicken Spinach Wraps",
    "Tomato Chicken Skillet"
  ]
}</code></pre><p>To submit this stage for a test, you have to run the FastAPI server from the terminal with the following command (here, main is the name of the file, <a href="https://main.py" rel="noopener noreferrer nofollow" target="_blank">main.py</a>, and app is the previously defined name of the FastAPI server):</p><pre><code class="language-python">uvicorn main:app --reload</code></pre><p>Once the server is running, you can submit the solution.</p>
</div>